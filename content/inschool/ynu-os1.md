---
title: YNU 操作系统课程期末复习 Part 1
date: 2019-07-09T23:37:15+08:00
description: "YNU 操作系统课程期末复习 Part 1 进程与处理机调度"
featuredImage: "https://alicdn.kmahyyg.xyz/asset_files/aether/cat_school.webp"
categories: ["school"]
draft: false
displayInMenu: false
displayInList: true
dropCap: false
---

# 操作系统

Part 1  进程与调度

# 绪论

1. 软件硬件分类和关系：CPU、内存、外部设备。
2. 操作系统的发展：手动、批处理、多道、分时、实时、通用、网络、分布式

- 批处理操作系统：联机、脱机、执行系统
- 多道操作系统：内存中存储了几道相互独立的程序，在程序控制下互相穿插独立运行。
- 分时操作系统：响应时间分成若干个大小相等的时间单位。

- 分时操作系统的特征：多路调制、独占、交互
- 实时和分时操作系统的区别：响应时间差异
- 分布式操作系统的特征：功能分布、坚强性、高可靠性
- 实时操作系统的特征：高可靠、安全、整体性强、不要求很强的会话能力

3. **操作系统的定义**：程序模块的集合：管理控制计算机系统中软件和硬件资源、合理组织计算机工作流程、以便有利地利用这些资源为用户提供一个功能强、使用方便的工作环境，从而 **在计算机与用户之间起到接口的作用** 。从 **资源的角度看，负责资源的分配、控制、调度、回收** 。
4. **操作系统的整体特征：** 并发、共享、异步、虚拟
5. 操作系统的功能：处理机管理、储存管理、设备管理、信息管理、用户接口

# 进程与线程

## 进程 

1. 现代操作系统的特点：程序并发、系统资源共享、用户操作随机
2. 进程概念：资源分配、共享、控制并发执行的基本单位
3. 程序执行：顺序执行和并发执行

- 顺序执行：顺序性、封闭性、可再现性
- 多道程序执行：独立性、随机性、资源共享
- 并发执行带来的问题：异步性、失去封闭性、失去可再现性
- **进程和程序** ：行为的一个规则称为程序，程序在处理机执行时所发生的活动成为进程。
- 进程的控制块：进程控制块 PCB + 程序段 + 数据结构集
- **PCB 包括** ：进程描述信息（UID、PID、Process Group）+ 进程控制信息（Status、Priority、Niceness、Memory Address）+ 资源占用信息（IO、Virtual Memory）+ 保护现场结构（寄存器）
- PCB 是 **系统对进程的唯一感知** ，进程结束后，系统通过释放 PCB 释放进程占用的资源。

- 程序的 **进程上下文** 是对进程执行活动的全过程的静态描述，其构成包括：寄存器 + 正文段 + 数据集 + PCB，可以分为用户级上下文、寄存器级上下文和系统级上下文。
- 进程在执行时拥有的地址空间成为进程空间，在 Userspace 时称为用户态，在 System Space 时称为核心态。

## 进程状态转换

进程在执行过程中有三个状态：

```
Running  <->  Ready <- Wait
    \             /
     \-> Blocked /
```

- **原语**：系统态下执行的某些具有特定功能的程序段
- 唤醒进程：等待事件发生唤醒 + 系统进程唤醒
- 进程状态转换的相关函数包括： fork() sleep() exit() wait() wakeup()

## 进程间通信

### 进程互斥、同步

进程互斥：

- **临界区** ：不允许多个并发进程交叉执行的一段程序称为临界区
- 临界区的问题原因：不同并发进程的程序段共享公用数据或变量引起的

解决互斥的几种办法：

- 使用加锁，但锁存在问题：Spin Lock，不断尝试导致的大量资源浪费
- 信号量 S 的物理含义：S>0：表示有S个资源可用；S=0 表示无资源可用；S<0 绝对值表示等待队列或链表中的进程个数。信号量的初值应大于等于0。

P 原语：P 是荷兰语Proberen（测试）的首字母。为阻塞原语，负责把当前进程由运行状态转换为阻塞状态，直到另外一个进程唤醒它。操作为：申请一个空闲资源（把信号量减1），则若成功，则退出；若失败，则该进程被阻塞；

V 原语：V 是荷兰语Verhogen（增加）的首字母。为唤醒原语，负责把一个被阻塞的进程唤醒，它有一个参数表，存放着等待被唤醒的进程信息。操作为：释放一个被占用的资源（把信号量加1），如果发现有被阻塞的进程，则选择一个唤醒之。

P(S)：表示申请一个资源，S 减 1；若 减 1 后仍S>=0，则该进程继续执行；若 减 1 后 S<0，表示已无资源可用，需要将自己阻塞起来。

V(S)：表示释放一个资源，S 加 1；若 加 1 后S>0，则该进程继续执行；若 加 1 后 S<=0，表示等待队列上有等待进程，需要将第一个等待的进程唤醒。

以生产者消费者问题为例：

```c
semaphore mutex=1; //临界区互斥信号量
semaphore empty=n;  //空闲缓冲区
semaphore full=0;  //缓冲区初始化为空
producer () { //生产者进程
    while(1){
        produce an item in nextp;  //生产数据
        P(empty);  //获取空缓冲区单元
        P(mutex);  //进入临界区.
        add nextp to buffer;  //将数据放入缓冲区
        V(mutex);  //离开临界区,释放互斥信号量
        V(full);  //满缓冲区数加1
    }
}

consumer () {  //消费者进程
    while(1){
        P(full);  //获取满缓冲区单元
        P(mutex);  // 进入临界区
        remove an item from buffer;  //从缓冲区中取出数据
        V (mutex);  //离开临界区，释放互斥信号量
        V (empty) ;  //空缓冲区数加1
        consume the item;  //消费数据
    }
}
```

### InterProcess Communicate

进程间的通信分为低级和高级，低级通信只能用于传输状态和整数值，信息量小、效率低、编程复杂。高级通信，可以用于传输任意数量的数据，包括三种方式：消息缓冲区、邮箱机制和 PIPE。 在单机系统中进程间的通信可以分为：会话式、主从式、消息和邮箱机制、共享存储区方式。

- 主从：完全受到主进程的控制而且主从关系固定
- 会话：使用进程调用服务进程提供的服务，调用前必须经由服务进程许可。
- 消息邮箱：发送、接受进程地位平等，使用缓冲区处理。
- 共享存储区：Shared Memory。
- 管程：是编程语言提供的一种抽象数据结构，用于多线程互斥访问共享资源。首先，是互斥访问，即任一时刻只有一个线程在执行管程代码；第二，正在管程内的线程可以放弃对管程的控制权，等待某些条件发生再继续执行。

### 资源分配：死锁

死锁的原因是并发进程的资源竞争。 死锁发生的必要条件包括：互斥条件、非剥夺条件、部分分配条件、环路条件。

死锁的解决方法：

- 预防：限制并发请求
- 避免：分配资源时提前预测占用
- 检测与恢复
- 不理会死锁

死锁的预防与解决：

- 破坏互斥条件
- 破坏部分分配条件：一次性申请所有资源
- 允许资源抢占
- 资源定序：按序编号，只能申请比自己编号大的资源。申请资源时必须释放比自己欲申请资源编号大的资源。

死锁避免—— **银行家算法** ：（缺点：要求事先声明最大占用量）

1. 检查当前需求矩阵中是否存在一行能够被完全满足，如果存在则分配。否则，标记为死锁。
2. 重复上述步骤。

死锁检测：判断是否存在循环等待。
潜在的死锁检测后恢复方式：撤销进程，挂起进程后强制剥夺资源。

哲学家就餐问题：

```c
semaphore chopstick[5] = {1,1,1,1,1}; //初始化信号量
semaphore mutex=1;  //设置取筷子的信号量
Philosopher_i(){ //i号哲学家的进程
    while(1)
    {
        P (mutex) ; //在取筷子前获得互斥量
        P (chopstick [i]) ; //取左边筷子
        P (chopstick[ (i+1) %5]) ;  //取右边筷子
        V (mutex) ; //释放取筷子的信号量
        eat;  //进餐
        V(chopstick[i] ) ;  //放回左边筷子
        V(chopstick[ (i+l)%5]) ;  //放回右边筷子
        think;  // 思考
    }
}
```

## 线程

进程内的基本调度单位称为线程，进程是资源的基本调度单位，所有线程共享同一进程的地址空间。进程调度与切换均由 OS 完成，线程调度切换可以在用户态完成。

线程包括三个状态：执行、就绪、阻塞

线程的五个相关操作： Spawn, Block, Unblock, Schedule, Finish

用户级线程的调度只进行上下文切换。

# 处理机调度

处理机调度：分级调度-作业调度（高级调度）、交换调度（中级调度）、进程调度（低级调度）、线程调度

分时系统中不存在作业调度，实时系统中不配置作业调度。

- CPU 使用率 = 使用时间 / 总时间
- 响应时间 = 等待时间 + 运行时间
- **周转时间** = 完成时间 - 到达时间
- **带权周转时间** = 周转时间 / 运行时间
- 等待时间 = 开始时间 - 提交时间
- 完成时刻 = 开始时刻 + 运行时间

## 作业调度

作业可能对应多个进程，进程是调度的基本单位。作业由：程序、数据、作业说明书三部分组成。

程序：问题求解的算法描述，数据：程序加工的对象（非必须），作业说明书：告诉操作系统本作业的程序和数据的控制流程和要求。

加工步骤：编译、连接、运行

作业的状态： 提交 -> 后备 -> 运行 -> 完成

## 进程调度

进程调度：记录系统中进程的执行情况，选择占有处理机的进程，进行进程上下文切换

引起调度的原因： 进程执行完毕，进程自我阻塞，进程分配的时间片用完，进程提出IO请求后被阻塞，根据进程优先级被剥夺资源。

进程调度的方式：

- 非剥夺：适用于批处理系统，让进程一直执行直至阻塞或完毕
- 剥夺：根据时间片或优先级原则调度

进程上下文：包括正文段、数据段、硬件寄存器、有关数据结构

进程上下文切换： 

1. 决定是否进行上下文切换并检查是否允许上下文切换
2. 保存当前执行进程的上下文
3. 按照进程调度算法，选择处于就绪态的进程执行
4. 恢复/装配进程上下文，将 CPU 控制权交由对应进程

## 进程调度算法

- First Come First Serve (FCFS)
- Shortest Job First (SJF)
- Round Robin (RR)

分配固定的时间片给每个进程，到时立即收回。挂起进程，等待下一次分配。

- Round Robin with Multiple Level Feedback (RRwMF)

将就绪队列按照进程类型和阻塞原因分类后按 FCFS 排列，同一队列内优先级相同，不同队列优先级不同。

先进入的放第一队列末尾，分配时间片内执行完则撤离，否则放入下一队列，重复上述过程，直至执行完毕。

队列优先级越高的越先执行，最后一个最低优先级的队列按照 RR 执行。

- Priority Scheduling (PS)

优先级调度分为静态优先级和动态优先级。静态优先级在进程创建时确定，确定依据有：用户要求、进程类型、资源需求。动态优先级则考虑等待时间和已占用时间或资源占用等，等待时间延长则优先级提高，执行一个时间片就降低一次优先级。

具体的一个实现：线性优先级调度算法（Selfish Round-Robin, SRR）

SRR 中存在两个就绪队列：
  - 新创建进程队列： FCFS, Priority += a
  - 享受服务队列： FCFS，存储已经得到时间片服务的进程， Priority += b

当新创建进程队列队头进程和享受服务队列进程队尾进程优先级相同时，调入享受服务队列。

b > a，FCFS 算法; a > b = 0，RR 算法。

- Highest Response Ratio Next (HRRN)

ResponseRatio 算法 = 1 + 已等待时间/要求运行时间

计算方法：对应队列实行 FCFS，执行完第一个作业后依次计算 ResponseRatio，再行调度。

- 实时系统调度

实时系统调度分为：硬实时和软实时，硬实时要求必须完全满足任务时限，软实时允许有一定的延迟。

实时系统外部任务分为：周期性和非周期性人物，特点包括：有限等待时间、有限响应时间、用户控制、高可靠性、出错处理能力强。要求操作系统：快速切换进程与线程，快速外部响应中断，基于优先级的随时抢先式调度策略。
